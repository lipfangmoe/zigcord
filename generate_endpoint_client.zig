const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};

    const args = try std.process.argsAlloc(gpa.allocator());
    defer std.process.argsFree(gpa.allocator(), args);
    if (args.len != 2) {
        std.debug.panic("wrong number of arguments", .{});
    }

    const output_file_path = args[1];
    var output_file = try std.fs.cwd().createFile(output_file_path, .{});
    defer output_file.close();

    try output_file.writeAll(try generateEndpointClient(gpa.allocator()));
}

fn generateEndpointClient(allocator: std.mem.Allocator) ![]u8 {
    const template_path = "./src/rest/EndpointClient.zig.template";

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();

    const endpoints = try getEndpointFileNames(&arena);
    const decls = try endpointDecls(&arena, endpoints);
    var aw = std.Io.Writer.Allocating.init(allocator);
    defer aw.deinit();
    try aw.writer.writeAll(try std.fs.cwd().readFileAlloc(arena.allocator(), template_path, 100_000));
    try aw.writer.writeAll(decls);
    try aw.writer.flush();

    return aw.toOwnedSlice();
}

fn getEndpointFileNames(arena: *std.heap.ArenaAllocator) ![][]u8 {
    const allocator = arena.allocator();
    var file_names: std.ArrayList([]u8) = try .initCapacity(allocator, 100);

    const dir = try std.fs.cwd().openDir("./src/rest/endpoints", .{ .iterate = true });
    var iter = dir.iterateAssumeFirstIteration();
    while (try iter.next()) |file| {
        try file_names.append(allocator, try allocator.dupe(u8, file.name));
    }

    return file_names.toOwnedSlice(allocator);
}

fn endpointDecls(arena: *std.heap.ArenaAllocator, endpoint_files: []const []const u8) ![]u8 {
    const allocator = arena.allocator();
    var new_contents_aw = try std.Io.Writer.Allocating.initCapacity(allocator, 100_000);
    var new_contents = &new_contents_aw.writer;

    try new_contents.writeByte('\n');
    try new_contents.writeAll("// === generated by generate_endpoint_client.zig ===\n");
    for (endpoint_files) |endpoint_file| {
        const endpoint_from_cwd = try std.fmt.allocPrint(allocator, "./src/rest/endpoints/{s}", .{endpoint_file});
        const endpoint = endpoint_file[0 .. endpoint_file.len - ".zig".len];
        try new_contents.print("pub const {s} = @import(\"./endpoints/{s}\");\n", .{ endpoint, endpoint_file });
        for (try publicTopLevelFunctions(arena, endpoint_from_cwd)) |func_name| {
            try new_contents.print("pub const {s} = {s}.{0s};\n", .{ func_name, endpoint });
        }
    }
    return try new_contents_aw.toOwnedSlice();
}

fn publicTopLevelFunctions(arena: *std.heap.ArenaAllocator, file_path: []const u8) ![][]u8 {
    const allocator = arena.allocator();
    var funcs: std.ArrayList([]u8) = try .initCapacity(allocator, 100);

    var buf: [10_000]u8 = undefined;
    var file = try std.fs.cwd().openFile(file_path, .{});
    var file_reader = file.reader(&buf);
    while (try file_reader.interface.takeDelimiter('\n')) |line| {
        if (std.mem.startsWith(u8, line, "pub fn")) {
            const start = "pub fn ".len;
            const end = std.mem.indexOfScalar(u8, line, '(') orelse return error.NoParenthesis;
            const func_name = try allocator.dupe(u8, line[start..end]);
            try funcs.append(allocator, func_name);
        }
        if (std.mem.startsWith(u8, line, "pub const")) {
            const start = "pub const ".len;
            const end = std.mem.indexOfScalarPos(u8, line, start, ' ') orelse return error.NoIdentifierEnd;
            const const_name = try allocator.dupe(u8, line[start..end]);
            try funcs.append(allocator, const_name);
        }
    }

    return funcs.toOwnedSlice(allocator);
}
